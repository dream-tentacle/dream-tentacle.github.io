<!DOCTYPE html>
<html lang="zh_CN" data-theme-mode="light" data-light-theme="daylight" data-dark-theme="midnight">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"/>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="stylesheet" type="text/css" id="baseStyle" href="stage/build/export/base.css?3.0.2"/>
    <link rel="stylesheet" type="text/css" id="themeDefaultStyle" href="appearance/themes/daylight/theme.css?3.0.2"/>
    
    <title>E:\桌面\问求 - 思源笔记  v3.0.2</title>
    <style>
        body {font-family: var(--b3-font-family);background-color: var(--b3-theme-background);color: var(--b3-theme-on-background)}
        .b3-typography, .protyle-wysiwyg, .protyle-title {font-size:22px !important}
.b3-typography code:not(.hljs), .protyle-wysiwyg span[data-type~=code] { font-variant-ligatures: none }
.li > .protyle-action {height:43px;line-height: 43px}
.protyle-wysiwyg [data-node-id].li > .protyle-action ~ .h1, .protyle-wysiwyg [data-node-id].li > .protyle-action ~ .h2, .protyle-wysiwyg [data-node-id].li > .protyle-action ~ .h3, .protyle-wysiwyg [data-node-id].li > .protyle-action ~ .h4, .protyle-wysiwyg [data-node-id].li > .protyle-action ~ .h5, .protyle-wysiwyg [data-node-id].li > .protyle-action ~ .h6 {line-height:43px;}
.protyle-wysiwyg [data-node-id].li > .protyle-action:after {height: 22px;width: 22px;margin:-11px 0 0 -11px}
.protyle-wysiwyg [data-node-id].li > .protyle-action svg {height: 14px}
.protyle-wysiwyg [data-node-id].li:before {height: calc(100% - 43px);top:43px}
.protyle-wysiwyg [data-node-id] [spellcheck] {min-height:35px;}
.protyle-wysiwyg [data-node-id] {}
.protyle-wysiwyg .li {min-height:43px}
.protyle-gutters button svg {height:35px}
        
        
    </style>
</head>
<body>
<div class="b3-typography" 
style="max-width: 800px;margin: 0 auto;" 
id="preview"><h1 id="20240314100232-bs1bx4s" updated="20240314100232">问求</h1>
<h1 id="20240314100232-z7cm5a2" updated="20240314100232">群论</h1>
<h3 id="20240314100232-duvb55d" updated="20240314100232">9. Isomorphism</h3>
<h5 id="20240314100232-g6csppu" updated="20240314100232">同构的定义</h5>
<p id="20240314100232-gxg10rq" updated="20240314100232">Isomorphism (同构) 将两个群画了一个“等号”，这两个群可能表示不同，但元素的运算关系全都相同。</p>
<blockquote id="20240314100232-7ue45bu" updated="20240314100232">
<p id="20240314100232-x99c26e" updated="20240314100232">定义：对两个群<span data-type="inline-math" data-subtype="math" data-content="(G,\cdot),(H,\circ)" contenteditable="false" class="render-node"></span>，如果存在双射<span data-type="inline-math" data-subtype="math" data-content="\phi:G\rightarrow H" contenteditable="false" class="render-node"></span>, 使得<span data-type="inline-math" data-subtype="math" data-content="\phi(a\cdot b)=\phi(a)\circ \phi(b)" contenteditable="false" class="render-node"></span>对任意<span data-type="inline-math" data-subtype="math" data-content="a,b\in G" contenteditable="false" class="render-node"></span>成立，则它们同构。写作<span data-type="inline-math" data-subtype="math" data-content="G\cong H" contenteditable="false" class="render-node"></span></p>
</blockquote>
<p id="20240314100232-mawyn6q" updated="20240314100232">除了运算关系，当然群的阶也是相同的，再结合子群的阶是原来的群的阶的因子，可以证伪一些命题。</p>
<p id="20240314100232-dk3b2ut" updated="20240314100232">显然同构是一种等价关系，因此在讨论时，我们可以从同构的视角将不同的群分为不同的等价类。up to isomorphism意为在同构视角下研究。</p>
<h5 id="20240314100232-lgq9cfi" updated="20240314100232">Cayley's Theorem</h5>
<p id="20240314100232-ga4c8lq" updated="20240314100232">当我们在研究陪集的时候会发现，对于<span data-type="inline-math" data-subtype="math" data-content="gH" contenteditable="false" class="render-node"></span>，<span data-type="inline-math" data-subtype="math" data-content="g" contenteditable="false" class="render-node"></span>就像是一个双射函数一样，将<span data-type="inline-math" data-subtype="math" data-content="H" contenteditable="false" class="render-node"></span>中的所有元素映射到了另一个集合。下面我们用这个思想得到cayley's theorem。</p>
<p id="20240314100232-9y9ntg2" updated="20240314100232">我们将任何一个元素<span data-type="inline-math" data-subtype="math" data-content="g\in G" contenteditable="false" class="render-node"></span>都能看成一个双射函数，而显然双射函数实质是一种permutation。容易证明<span data-type="inline-math" data-subtype="math" data-content="\lambda_g(x)=gx" contenteditable="false" class="render-node"></span>确实是双射。</p>
<p id="20240314100232-npi4nbh" updated="20240314100232">定义<span data-type="inline-math" data-subtype="math" data-content="\phi(g)=\lambda_g" contenteditable="false" class="render-node"></span>，易证<span data-type="inline-math" data-subtype="math" data-content="\phi:G\rightarrow S" contenteditable="false" class="render-node"></span>是一个双射，其中<span data-type="inline-math" data-subtype="math" data-content="S" contenteditable="false" class="render-node"></span>是所有<span data-type="inline-math" data-subtype="math" data-content="\lambda_g" contenteditable="false" class="render-node"></span>构成的permutation集合。</p>
<p id="20240314100232-o3yemry" updated="20240314100232">因此任何群都同构于一个permutation。</p>
<h5 id="20240314100232-r9y70zi" updated="20240314100232">外直积</h5>
<p id="20240314100232-ga2jsfm" updated="20240314100232">群不仅可以建立全等关系，也可以构成运算上的关系。若干群可以构成更高维的群，一个大的群也可以分解为若干群。</p>
<p id="20240314100232-w8fhlb3" updated="20240314100232">Cartesian product （笛卡儿积）也叫external direct product，是将若干群的元素直接构成一个多元组。</p>
<blockquote id="20240314100232-h0tr7j3" updated="20240314100232">
<p id="20240314100232-qgi0f6v" updated="20240314100232">定义：对于群<span data-type="inline-math" data-subtype="math" data-content="(G,\cdot),(H,\circ)" contenteditable="false" class="render-node"></span>，<span data-type="inline-math" data-subtype="math" data-content="g_i\in G,h_i \in H" contenteditable="false" class="render-node"></span>，则笛卡儿积<span data-type="inline-math" data-subtype="math" data-content="G\times H" contenteditable="false" class="render-node"></span>是由<span data-type="inline-math" data-subtype="math" data-content="(g,h)" contenteditable="false" class="render-node"></span>构成的群，运算为<span data-type="inline-math" data-subtype="math" data-content="(g_1,h_1)(g_2,h_2)=(g_1\cdot g_2,h_1\circ h_2)" contenteditable="false" class="render-node"></span>。</p>
</blockquote>
<p id="20240314100232-juuzoip" updated="20240314100232">对于生成元，如果<span data-type="inline-math" data-subtype="math" data-content="g\in G,h\in H" contenteditable="false" class="render-node"></span>，它们的阶分别为<span data-type="inline-math" data-subtype="math" data-content="m,n" contenteditable="false" class="render-node"></span>，则<span data-type="inline-math" data-subtype="math" data-content="(g,h)" contenteditable="false" class="render-node"></span>的阶为<span data-type="inline-math" data-subtype="math" data-content="\mathrm{lcm}(m,n)" contenteditable="false" class="render-node"></span>。（用定义易证）</p>
<p id="20240314100232-g8ml6rp" updated="20240314100232">这就引出了笛卡尔积相关的一个等价关系：<span data-type="inline-math" data-subtype="math" data-content="\mathrm{lcm}(m,n)=1" contenteditable="false" class="render-node"></span>当且仅当<span data-type="inline-math" data-subtype="math" data-content="\Z_m\times\Z_n \cong\Z_{mn}" contenteditable="false" class="render-node"></span>。首先，如果lcm不为1，则根据上面的可以得出任意元素的阶都小于<span data-type="inline-math" data-subtype="math" data-content="mn" contenteditable="false" class="render-node"></span>，因此<span data-type="inline-math" data-subtype="math" data-content="\Z_m\times\Z_n" contenteditable="false" class="render-node"></span>不是循环群，但<span data-type="inline-math" data-subtype="math" data-content="\Z_{mn}" contenteditable="false" class="render-node"></span>是循环群，于是不同构。</p>
<h5 id="20240314100232-z7e4q7v" updated="20240314100232">内直积</h5>
<p id="20240314100232-ebogo0g" updated="20240314100232">Internal direct product是这样的一种群，它可以拆成两个群，每个元素都可以表示为两个子群的元素的运算结果。</p>
<blockquote id="20240314100232-46fipll" updated="20240314100232">
<p id="20240314100232-wc3bs3t" updated="20240314100232">定义：如果一个群<span data-type="inline-math" data-subtype="math" data-content="G" contenteditable="false" class="render-node"></span>满足<span data-type="inline-math" data-subtype="math" data-content="G=HK=\{hk|h\in H,k\in K\}" contenteditable="false" class="render-node"></span>，且<span data-type="inline-math" data-subtype="math" data-content="H\cap K=\{e\}" contenteditable="false" class="render-node"></span>，<span data-type="inline-math" data-subtype="math" data-content="\forall h\in H,\forall k\in K,hk=kh" contenteditable="false" class="render-node"></span>，则称<span data-type="inline-math" data-subtype="math" data-content="G" contenteditable="false" class="render-node"></span>是<span data-type="inline-math" data-subtype="math" data-content="HK" contenteditable="false" class="render-node"></span>的internal direct product</p>
</blockquote>
<p id="20240314100232-o54f811" updated="20240314100232">内直积和外直积有着很密切的关系。事实上，如果<span data-type="inline-math" data-subtype="math" data-content="G" contenteditable="false" class="render-node"></span>是<span data-type="inline-math" data-subtype="math" data-content="H,K" contenteditable="false" class="render-node"></span>的内直积，则<span data-type="inline-math" data-subtype="math" data-content="G\cong H\times K" contenteditable="false" class="render-node"></span></p>
<p id="20240314100232-tibfj4g" updated="20240314100232">观察外直积和内直积的关系，一个是二元组，一个是运算，如果二元组与运算的结果是一一对应的，那么证明思路就有了。首先从运算结果入手，如果<span data-type="inline-math" data-subtype="math" data-content="g=hk=h'k'" contenteditable="false" class="render-node"></span>，则<span data-type="inline-math" data-subtype="math" data-content="kk'^{-1}=h^{-1}h'" contenteditable="false" class="render-node"></span>，根据<span data-type="inline-math" data-subtype="math" data-content="H\cap K=\{e\}" contenteditable="false" class="render-node"></span>知<span data-type="inline-math" data-subtype="math" data-content="kk'^{-1}=h^{-1}h'=e" contenteditable="false" class="render-node"></span>，则<span data-type="inline-math" data-subtype="math" data-content="h=h',k=k'" contenteditable="false" class="render-node"></span>，所以运算结果是唯一对应于参与运算的两个元素的。</p>
<p id="20240314100232-qq6l0vw" updated="20240314100232">令<span data-type="inline-math" data-subtype="math" data-content="\phi(g)=(h,k)" contenteditable="false" class="render-node"></span>，其中<span data-type="inline-math" data-subtype="math" data-content="g=hk" contenteditable="false" class="render-node"></span>，根据上文这是良定义的函数。<span data-type="inline-math" data-subtype="math" data-content="\phi(g_1g_2)=\phi(h_1k_1h_2k_2)=\phi(h_1h_2k_1k_2)=(h_1h_2,k_1k_2)=\phi(g_1)\phi(g_2)" contenteditable="false" class="render-node"></span>。证明双射很容易。</p>
<h3 id="20240314100232-tl35f14" updated="20240314100232">10.Normal Subgroups and Factor Groups</h3>
<h5 id="20240314100232-lsccjbf" updated="20240314100232">Normal Subgroups</h5>
<p id="20240314100232-0e1lk7m" updated="20240314100232">子群的左右陪集不一定相等，如果相等，则可以用于构建Factor Group。</p>
<blockquote id="20240314100232-oehul23" updated="20240314100232">
<p id="20240314100232-4u90mfv" updated="20240314100232">定义：<span data-type="inline-math" data-subtype="math" data-content="G" contenteditable="false" class="render-node"></span>的子群<span data-type="inline-math" data-subtype="math" data-content="H" contenteditable="false" class="render-node"></span>如果满足<span data-type="inline-math" data-subtype="math" data-content="\forall g\in G,gH=Hg" contenteditable="false" class="render-node"></span>，则<span data-type="inline-math" data-subtype="math" data-content="H" contenteditable="false" class="render-node"></span>是<span data-type="inline-math" data-subtype="math" data-content="G" contenteditable="false" class="render-node"></span>的正规子群。</p>
</blockquote>
<p id="20240314100232-diabj6t" updated="20240314100232">在正规子群相关证明中，用的比较多的应该是<span data-type="inline-math" data-subtype="math" data-content="\forall g\in G, \forall h\in H,ghg^{-1}\in H" contenteditable="false" class="render-node"></span>，这可以用于证明某些具备固定性质的群<span data-type="inline-math" data-subtype="math" data-content="H" contenteditable="false" class="render-node"></span>是正规子群。</p>
<h5 id="20240314100232-dwlrr71" updated="20240314100232">Factor Groups</h5>
<p id="20240314100232-3mm93r6" updated="20240314100232">我们知道，一个子群<span data-type="inline-math" data-subtype="math" data-content="H" contenteditable="false" class="render-node"></span>可以确定一种等价关系，即<span data-type="inline-math" data-subtype="math" data-content="g_1g_2^{-1}\in H" contenteditable="false" class="render-node"></span>，或者是<span data-type="inline-math" data-subtype="math" data-content="g_1H=g_2H" contenteditable="false" class="render-node"></span>。在10、11章节中我们往往需要证明一个陪集的操作不依赖于<span data-type="inline-math" data-subtype="math" data-content="g_1" contenteditable="false" class="render-node"></span>或<span data-type="inline-math" data-subtype="math" data-content="g_2" contenteditable="false" class="render-node"></span>这个符号，也就是说这个等价类里面每个元素拿出来进行运算的结果都必须是一样的，这在证明某个函数是良定义时非常重要。</p>
<p id="20240314100232-vyepcvv" updated="20240314100232">Factor Group是这样一种群，它的集合元素构成<span data-type="inline-math" data-subtype="math" data-content="G" contenteditable="false" class="render-node"></span>的一个划分，且每个划分同势；它的运算和<span data-type="inline-math" data-subtype="math" data-content="G" contenteditable="false" class="render-node"></span>的运算很相似。</p>
<blockquote id="20240314100232-xqpzxou" updated="20240314100232">
<p id="20240314100232-iqoga4y" updated="20240314100232">定义：<span data-type="inline-math" data-subtype="math" data-content="G" contenteditable="false" class="render-node"></span>有一个正规子群<span data-type="inline-math" data-subtype="math" data-content="N" contenteditable="false" class="render-node"></span>，<span data-type="inline-math" data-subtype="math" data-content="N" contenteditable="false" class="render-node"></span>的陪集构成一个群，运算为<span data-type="inline-math" data-subtype="math" data-content="(aN)(bN)=(ab)N" contenteditable="false" class="render-node"></span>，群写做<span data-type="inline-math" data-subtype="math" data-content="G/N" contenteditable="false" class="render-node"></span>，阶为<span data-type="inline-math" data-subtype="math" data-content="[G:N]" contenteditable="false" class="render-node"></span></p>
</blockquote>
<p id="20240314100232-lk38ffp" updated="20240314100232">我们需要证明此处的运算是良定义的。令<span data-type="inline-math" data-subtype="math" data-content="aN=bN,cN=dN" contenteditable="false" class="render-node"></span>，需要证明<span data-type="inline-math" data-subtype="math" data-content="(ac)N=(bd)N" contenteditable="false" class="render-node"></span>。易知<span data-type="inline-math" data-subtype="math" data-content="ab^{-1}\in N,cd^{-1}\in N" contenteditable="false" class="render-node"></span>，故存在<span data-type="inline-math" data-subtype="math" data-content="n_1\in N,b=an_1," contenteditable="false" class="render-node"></span> <span data-type="inline-math" data-subtype="math" data-content="n_2\in N,d=cn_2" contenteditable="false" class="render-node"></span>。<span data-type="inline-math" data-subtype="math" data-content="(bd)N=(an_1cn_2)N=an_1cN=an_1Nc=aNc=acN" contenteditable="false" class="render-node"></span>。这里运用了陪集的性质与正规子群的定义。</p>
<h5 id="20240314100232-fjr0ok9" updated="20240314100232">Simplicity</h5>
<p id="20240314100232-zbxi9c8" updated="20240314100232">没有非平凡正规子群的群称为Simple groups。书中对Alternating Groups <span data-type="inline-math" data-subtype="math" data-content="A_n(n\geq5)" contenteditable="false" class="render-node"></span>做出了讨论，并证明它是Simple group。要证明这个结论，主要的思路是：证明任意3-cycle属于子群时可以推到所有的其他元素，然后证明正规子群中的元素可以推出3-cycle。</p>
<p id="20240314100232-9cx41wf" updated="20240314100232">首先，书中证明了<span data-type="inline-math" data-subtype="math" data-content="A_n" contenteditable="false" class="render-node"></span>中的任意元素可以写做若干3-cycle的乘积，这是通过转化一对transposition得到的。</p>
<p id="20240314100232-nilmvis" updated="20240314100232">其次，证明<span data-type="inline-math" data-subtype="math" data-content="A_n" contenteditable="false" class="render-node"></span>的含有3-cycle的子群<span data-type="inline-math" data-subtype="math" data-content="N" contenteditable="false" class="render-node"></span>一定是<span data-type="inline-math" data-subtype="math" data-content="A_n" contenteditable="false" class="render-node"></span>。这里将所有的3-cycle表示为<span data-type="inline-math" data-subtype="math" data-content="(ijk)" contenteditable="false" class="render-node"></span>的乘积，其中<span data-type="inline-math" data-subtype="math" data-content="i,j" contenteditable="false" class="render-node"></span>固定，<span data-type="inline-math" data-subtype="math" data-content="k" contenteditable="false" class="render-node"></span>任取。然后由于<span data-type="inline-math" data-subtype="math" data-content="[(ij)(ak)](ija)^2[(ij)(ak)]^{-1}=(ijk)" contenteditable="false" class="render-node"></span>，所以所有<span data-type="inline-math" data-subtype="math" data-content="(ijk)" contenteditable="false" class="render-node"></span>形式的3-cycle都属于<span data-type="inline-math" data-subtype="math" data-content="N" contenteditable="false" class="render-node"></span>，因此所有3-cycle都属于<span data-type="inline-math" data-subtype="math" data-content="N" contenteditable="false" class="render-node"></span>，结合上一步即得证。</p>
<p id="20240314100232-sjpu5xe" updated="20240314100232">最后，将所有的even permutation分解，对其分类讨论，证明了包含非id的子群一定包含一个3-cycle，也就证明了最后的结论。</p>
<h3 id="20240314100232-m6leydl" updated="20240314100232">11. Homomorphisms</h3>
<h5 id="20240314100232-y27p525" updated="20240314100232">Homomorphisms</h5>
<p id="20240314100232-5izmodj" updated="20240314100232">同态有点像线性代数里的一种降维映射，因为可能两个不同的元素会映射到同一个元素，所以就降维了。</p>
<blockquote id="20240314100232-7601r66" updated="20240314100232">
<p id="20240314100232-ec2iyn4" updated="20240314100232">定义：对群<span data-type="inline-math" data-subtype="math" data-content="(G,\cdot),(H,\circ)" contenteditable="false" class="render-node"></span>的Homomorphism是一个映射<span data-type="inline-math" data-subtype="math" data-content="\phi:G\rightarrow H" contenteditable="false" class="render-node"></span>满足<span data-type="inline-math" data-subtype="math" data-content="\phi(g_1\cdot g_2)=\phi (g_1)\circ \phi(g_2)" contenteditable="false" class="render-node"></span>。</p>
</blockquote>
<p id="20240314100232-bkynpyp" updated="20240314100232"><span data-type="inline-math" data-subtype="math" data-content="\phi" contenteditable="false" class="render-node"></span>在<span data-type="inline-math" data-subtype="math" data-content="H" contenteditable="false" class="render-node"></span>中的值域被称为<span data-type="inline-math" data-subtype="math" data-content="\phi" contenteditable="false" class="render-node"></span>的Homomorphic image</p>
<p id="20240314100232-x8skpkz" updated="20240314100232">同态有一个很重要的性质，与正规子群有关。如果一个集合在<span data-type="inline-math" data-subtype="math" data-content="H" contenteditable="false" class="render-node"></span>中是正规的，那么它在<span data-type="inline-math" data-subtype="math" data-content="G" contenteditable="false" class="render-node"></span>中的逆象也是正规的。</p>
<p id="20240314100232-728p90l" updated="20240314100232">利用定义证明：<span data-type="inline-math" data-subtype="math" data-content="H_1\sube H" contenteditable="false" class="render-node"></span>是正规子群，逆象为<span data-type="inline-math" data-subtype="math" data-content="G_1" contenteditable="false" class="render-node"></span>，则<span data-type="inline-math" data-subtype="math" data-content="\forall h_1\in H_1,\forall h \in H,hh_1h^{-1}\in H_1" contenteditable="false" class="render-node"></span>，那么<span data-type="inline-math" data-subtype="math" data-content="\forall g_1\in G_1,\forall g\in G" contenteditable="false" class="render-node"></span>，<span data-type="inline-math" data-subtype="math" data-content="\phi(gg_1g^{-1})=\phi (g)\phi (g_1)[\phi(g)]^{-1}" contenteditable="false" class="render-node"></span>，<span data-type="inline-math" data-subtype="math" data-content="\phi(g)\in H,\phi (g_1)\in H_1" contenteditable="false" class="render-node"></span>，故<span data-type="inline-math" data-subtype="math" data-content="\phi(gg_1g^{-1})\in H_1" contenteditable="false" class="render-node"></span>，故<span data-type="inline-math" data-subtype="math" data-content="gg_1g^{-1}\in G" contenteditable="false" class="render-node"></span>。这里也用到了性质<span data-type="inline-math" data-subtype="math" data-content="\phi(g^{-1})=[\phi(g)]^{-1}" contenteditable="false" class="render-node"></span></p>
<p id="20240314100232-d48ygas" updated="20240314100232">上述性质对应了一个重要的性质，即Kernel。</p>
<blockquote id="20240314100232-g0uzdk9" updated="20240314100232">
<p id="20240314100232-m01mamf" updated="20240314100232">定义：<span data-type="inline-math" data-subtype="math" data-content="\phi" contenteditable="false" class="render-node"></span>是一个<span data-type="inline-math" data-subtype="math" data-content="G" contenteditable="false" class="render-node"></span>到<span data-type="inline-math" data-subtype="math" data-content="H" contenteditable="false" class="render-node"></span>的同态，则<span data-type="inline-math" data-subtype="math" data-content="\phi^{-1}(\{e_H\})" contenteditable="false" class="render-node"></span>是<span data-type="inline-math" data-subtype="math" data-content="\phi" contenteditable="false" class="render-node"></span>的核。</p>
</blockquote>
<p id="20240314100232-0vk5843" updated="20240314100232">核的性质很多，显然它是正规子群，此外比较重要的是它的势。一个核的陪集的所有元素都对应于同一个像，因此核的势就是<span data-type="inline-math" data-subtype="math" data-content="H" contenteditable="false" class="render-node"></span>中的所有非空逆象的势。</p>
<h5 id="20240314100232-hu0lxgs" updated="20240314100232">The Isomorphism Theorems</h5>
<p id="20240314100232-k18e5kj" updated="20240314100232">关于正规子群的陪集所确定的群，即Factor Group，实际上也构成了一种同态，也就是同一个等价类内的所有元素都映射到其对应的陪集。</p>
<blockquote id="20240314100232-7iak4l6" updated="20240314100232">
<p id="20240314100232-o2owt9g" updated="20240314100232">定义：<span data-type="inline-math" data-subtype="math" data-content="H" contenteditable="false" class="render-node"></span>是<span data-type="inline-math" data-subtype="math" data-content="G" contenteditable="false" class="render-node"></span>的一个正规子群，则natural homomorphism (canonical homomorphism)为<span data-type="inline-math" data-subtype="math" data-content="\phi:G\rightarrow G/H" contenteditable="false" class="render-node"></span>，<span data-type="inline-math" data-subtype="math" data-content="\phi(g)=gH" contenteditable="false" class="render-node"></span>。</p>
</blockquote>
<p id="20240314100232-ab1w45j" updated="20240314100232">此处的核是<span data-type="inline-math" data-subtype="math" data-content="H" contenteditable="false" class="render-node"></span>，是一个常用的结论。</p>
<p id="20240314100232-8pvu9zt" updated="20240314100232">这里的正规子群、陪集又和上面讲的核关系十分密切。一个<span data-type="inline-math" data-subtype="math" data-content="\phi:G\rightarrow H" contenteditable="false" class="render-node"></span>所确定的核<span data-type="inline-math" data-subtype="math" data-content="K" contenteditable="false" class="render-node"></span>很明显满足<span data-type="inline-math" data-subtype="math" data-content="[G:K]=|\phi(G)|" contenteditable="false" class="render-node"></span>，因为<span data-type="inline-math" data-subtype="math" data-content="K" contenteditable="false" class="render-node"></span>的所有陪集分别对应于一个像。因此就有了First Isomorphism Theorem：</p>
<blockquote id="20240314100232-wifuk8e" updated="20240314100232">
<p id="20240314100232-fi8g0oh" updated="20240314100232">如果<span data-type="inline-math" data-subtype="math" data-content="\psi:G\rightarrow H" contenteditable="false" class="render-node"></span>是一个群同态，有核<span data-type="inline-math" data-subtype="math" data-content="K" contenteditable="false" class="render-node"></span>，取<span data-type="inline-math" data-subtype="math" data-content="\phi:G\rightarrow G/K" contenteditable="false" class="render-node"></span>为Factor Group，则存在唯一的同构<span data-type="inline-math" data-subtype="math" data-content="\eta:G/K\rightarrow \psi(G)" contenteditable="false" class="render-node"></span>，<span data-type="inline-math" data-subtype="math" data-content="\eta\phi=\psi" contenteditable="false" class="render-node"></span>。</p>
</blockquote>
<p id="20240314100232-e8uzw5u" updated="20240314100232">事实上<span data-type="inline-math" data-subtype="math" data-content="\eta(gK)=\psi(g)" contenteditable="false" class="render-node"></span>，由于同一个陪集里的元素对应于同一个像，这个函数是良定义的。<span data-type="inline-math" data-subtype="math" data-content="\eta(g_1Kg_2K)=\eta(g_1g_2K)=\psi(g_1g_2) =\psi(g_1)\psi(g_2)=\eta(g_1K)\eta(g_2K)" contenteditable="false" class="render-node"></span>，所以<span data-type="inline-math" data-subtype="math" data-content="\eta" contenteditable="false" class="render-node"></span>是一个同态，易证是双射。</p>
<p id="20240314100232-p9fqgoo" updated="20240314100232">Second Isomorphism Theorem:</p>
<blockquote id="20240314100232-gajq18z" updated="20240314100232">
<p id="20240314100232-g1atjaf" updated="20240314100232"><span data-type="inline-math" data-subtype="math" data-content="H" contenteditable="false" class="render-node"></span>是<span data-type="inline-math" data-subtype="math" data-content="G" contenteditable="false" class="render-node"></span>的一个子群，<span data-type="inline-math" data-subtype="math" data-content="N" contenteditable="false" class="render-node"></span>是<span data-type="inline-math" data-subtype="math" data-content="G" contenteditable="false" class="render-node"></span>的一个正规子群，则<span data-type="inline-math" data-subtype="math" data-content="HN" contenteditable="false" class="render-node"></span>是<span data-type="inline-math" data-subtype="math" data-content="G" contenteditable="false" class="render-node"></span>的子群，<span data-type="inline-math" data-subtype="math" data-content="H\cap N" contenteditable="false" class="render-node"></span>是<span data-type="inline-math" data-subtype="math" data-content="H" contenteditable="false" class="render-node"></span>的正规子群，且<span data-type="inline-math" data-subtype="math" data-content="H/(H\cap N) \cong (HN)/N" contenteditable="false" class="render-node"></span>。</p>
</blockquote>
<p id="20240314100232-8pslxby" updated="20240314100232">并不是所有的两个子群进行内积运算都得到一个群，而正规子群使得形如<span data-type="inline-math" data-subtype="math" data-content="h_1n_1h_2n_2" contenteditable="false" class="render-node"></span>中两个群的元素<span data-type="inline-math" data-subtype="math" data-content="n_1h_2" contenteditable="false" class="render-node"></span>可以左右交换并替换<span data-type="inline-math" data-subtype="math" data-content="n_1" contenteditable="false" class="render-node"></span>为另一个<span data-type="inline-math" data-subtype="math" data-content="N" contenteditable="false" class="render-node"></span>中的元素，从而让<span data-type="inline-math" data-subtype="math" data-content="H" contenteditable="false" class="render-node"></span>和<span data-type="inline-math" data-subtype="math" data-content="N" contenteditable="false" class="render-node"></span>中的元素靠在一起得到它们中的元素。当然，其他性质也是如此得到。（<span data-type="inline-math" data-subtype="math" data-content="h_1n_1h_2n_2=h_1h_2n_3n_2\in HN" contenteditable="false" class="render-node"></span>）</p>
<p id="20240314100232-4g9xbp9" updated="20240314100232">对于<span data-type="inline-math" data-subtype="math" data-content="H\cap N" contenteditable="false" class="render-node"></span>，利用了群和正规子群的性质。<span data-type="inline-math" data-subtype="math" data-content="h\in H,n\in H\cap N" contenteditable="false" class="render-node"></span>，则由群<span data-type="inline-math" data-subtype="math" data-content="H" contenteditable="false" class="render-node"></span>的性质，<span data-type="inline-math" data-subtype="math" data-content="hnh^{-1}\in H" contenteditable="false" class="render-node"></span>，由正规子群的性质，<span data-type="inline-math" data-subtype="math" data-content="hnh^{-1}\in N" contenteditable="false" class="render-node"></span>，所以<span data-type="inline-math" data-subtype="math" data-content="hnh^{-1}\in H\cap N" contenteditable="false" class="render-node"></span>，得到了正规子群。</p>
<p id="20240314100232-uau7ae3" updated="20240314100232">对于最后一个性质，感性的认知是这样的：</p>
<p id="20240314100232-k5oy6ob" updated="20240314100232">​<span class="img" style="width: 50%;"><img src="assets/image-20240313120250-wnz4pq4.png" alt="image" style="width: 10000px;" parent-style="width: 50%;" /></span>​</p>
<p id="20240314100232-dz2hv4q" updated="20240314100232"><span data-type="inline-math" data-subtype="math" data-content="H" contenteditable="false" class="render-node"></span>与<span data-type="inline-math" data-subtype="math" data-content="H\cap N" contenteditable="false" class="render-node"></span>的关系类似于<span data-type="inline-math" data-subtype="math" data-content="HN" contenteditable="false" class="render-node"></span>与<span data-type="inline-math" data-subtype="math" data-content="N" contenteditable="false" class="render-node"></span>的关系。</p>
<p id="20240314100232-twfygvr" updated="20240314100232">令<span data-type="inline-math" data-subtype="math" data-content="\phi:H\rightarrow HN/N" contenteditable="false" class="render-node"></span>，<span data-type="inline-math" data-subtype="math" data-content="\phi(h)=hN" contenteditable="false" class="render-node"></span>，则<span data-type="inline-math" data-subtype="math" data-content="\phi(h_1h_2)=h_1h_2N=(h_1N)(h_2N)=\phi(h_1)\phi(h_2)" contenteditable="false" class="render-node"></span>，所以<span data-type="inline-math" data-subtype="math" data-content="\phi" contenteditable="false" class="render-node"></span>是群同态。结合同构第一定理，<span data-type="inline-math" data-subtype="math" data-content="H/ker \phi \cong \phi(H)" contenteditable="false" class="render-node"></span>，此处<span data-type="inline-math" data-subtype="math" data-content="ker\phi" contenteditable="false" class="render-node"></span>即<span data-type="inline-math" data-subtype="math" data-content="\{h\in H| hN=N\}" contenteditable="false" class="render-node"></span>，即<span data-type="inline-math" data-subtype="math" data-content="\{h\in H,h\in N\}" contenteditable="false" class="render-node"></span>，即<span data-type="inline-math" data-subtype="math" data-content="H\cap N" contenteditable="false" class="render-node"></span>。而<span data-type="inline-math" data-subtype="math" data-content="\phi(H)" contenteditable="false" class="render-node"></span>是否是<span data-type="inline-math" data-subtype="math" data-content="HN/N" contenteditable="false" class="render-node"></span>呢？对任意<span data-type="inline-math" data-subtype="math" data-content="hnN\in HN/N" contenteditable="false" class="render-node"></span>，<span data-type="inline-math" data-subtype="math" data-content="\phi(h)=hN=hnN" contenteditable="false" class="render-node"></span>，故满射，<span data-type="inline-math" data-subtype="math" data-content="\phi(H)=HN/N" contenteditable="false" class="render-node"></span>。</p>
<p id="20240314100232-2dw98ev" updated="20240314100232">因此得到了<span data-type="inline-math" data-subtype="math" data-content="H/(H\cap N)\cong HN/N" contenteditable="false" class="render-node"></span></p>
<p id="20240314100232-irumgyh" updated="20240314100232">Correspondence Theorem：</p>
<blockquote id="20240314100232-sogryxp" updated="20240314100232">
<p id="20240314100232-mya1c4q" updated="20240314100232"><span data-type="inline-math" data-subtype="math" data-content="N" contenteditable="false" class="render-node"></span>是<span data-type="inline-math" data-subtype="math" data-content="G" contenteditable="false" class="render-node"></span>的一个正规子群，<span data-type="inline-math" data-subtype="math" data-content="G" contenteditable="false" class="render-node"></span>所有包含<span data-type="inline-math" data-subtype="math" data-content="N" contenteditable="false" class="render-node"></span>的子群与<span data-type="inline-math" data-subtype="math" data-content="G/N" contenteditable="false" class="render-node"></span>的所有子群存在一个双射<span data-type="inline-math" data-subtype="math" data-content="\phi(H)=H/N" contenteditable="false" class="render-node"></span>，且<span data-type="inline-math" data-subtype="math" data-content="H" contenteditable="false" class="render-node"></span>是正规子群当且仅当<span data-type="inline-math" data-subtype="math" data-content="H/N" contenteditable="false" class="render-node"></span>也是正规子群。</p>
</blockquote>
<p id="20240314100232-cb94glb" updated="20240314100232">首先要证明的应当是映射是正确的，即<span data-type="inline-math" data-subtype="math" data-content="H/N" contenteditable="false" class="render-node"></span>确实是<span data-type="inline-math" data-subtype="math" data-content="G/N" contenteditable="false" class="render-node"></span>的一个子群。因此，设<span data-type="inline-math" data-subtype="math" data-content="aN,bN" contenteditable="false" class="render-node"></span>是<span data-type="inline-math" data-subtype="math" data-content="H/N" contenteditable="false" class="render-node"></span>的两个元素，由<span data-type="inline-math" data-subtype="math" data-content="H" contenteditable="false" class="render-node"></span>是子群知<span data-type="inline-math" data-subtype="math" data-content="ab^{-1}\in H" contenteditable="false" class="render-node"></span>，故<span data-type="inline-math" data-subtype="math" data-content="(aN)(b^{-1}N)=ab^{-1}N \in H/N" contenteditable="false" class="render-node"></span>，所以<span data-type="inline-math" data-subtype="math" data-content="H/N" contenteditable="false" class="render-node"></span>是子群。</p>
<p id="20240314100232-0ppa31a" updated="20240314100232">证明满射，只需要用定义即可，但单射需要一点技巧，主要是关于群的性质。如果<span data-type="inline-math" data-subtype="math" data-content="H_1/N=H_2/N" contenteditable="false" class="render-node"></span>，则对<span data-type="inline-math" data-subtype="math" data-content="h_1\in H_1" contenteditable="false" class="render-node"></span>，<span data-type="inline-math" data-subtype="math" data-content="h_1N\in H_1/N" contenteditable="false" class="render-node"></span>，则存在<span data-type="inline-math" data-subtype="math" data-content="h_2\in H_2" contenteditable="false" class="render-node"></span>使得<span data-type="inline-math" data-subtype="math" data-content="h_1N=h_2N" contenteditable="false" class="render-node"></span>，由于<span data-type="inline-math" data-subtype="math" data-content="h_2" contenteditable="false" class="render-node"></span>和<span data-type="inline-math" data-subtype="math" data-content="N" contenteditable="false" class="render-node"></span>中的元素都属于<span data-type="inline-math" data-subtype="math" data-content="H_2" contenteditable="false" class="render-node"></span>，所以其结果也属于，因此<span data-type="inline-math" data-subtype="math" data-content="h_1N\sub H_2" contenteditable="false" class="render-node"></span>。因为<span data-type="inline-math" data-subtype="math" data-content="N" contenteditable="false" class="render-node"></span>中元素都属于<span data-type="inline-math" data-subtype="math" data-content="H_2" contenteditable="false" class="render-node"></span>，那么<span data-type="inline-math" data-subtype="math" data-content="h_1" contenteditable="false" class="render-node"></span>也属于<span data-type="inline-math" data-subtype="math" data-content="H_2" contenteditable="false" class="render-node"></span>，故<span data-type="inline-math" data-subtype="math" data-content="H_1\sub H_2" contenteditable="false" class="render-node"></span>，对称地有<span data-type="inline-math" data-subtype="math" data-content="H_2\sub H_1" contenteditable="false" class="render-node"></span>，故二者相等。</p>
<p id="20240314100232-23udb1h" updated="20240314100232">对于最后一个结论的充分性，用到了核的正规性。容易构造并证明同态<span data-type="inline-math" data-subtype="math" data-content="\phi:G/N\rightarrow G/H" contenteditable="false" class="render-node"></span>，使得<span data-type="inline-math" data-subtype="math" data-content="\phi(gN)=gH" contenteditable="false" class="render-node"></span>。这个同态的核即使得<span data-type="inline-math" data-subtype="math" data-content="\phi(gN)=gH=H" contenteditable="false" class="render-node"></span>的元素，即所有满足<span data-type="inline-math" data-subtype="math" data-content="g\in  H" contenteditable="false" class="render-node"></span>的<span data-type="inline-math" data-subtype="math" data-content="gN" contenteditable="false" class="render-node"></span>，所以就是<span data-type="inline-math" data-subtype="math" data-content="H/N" contenteditable="false" class="render-node"></span>，因此<span data-type="inline-math" data-subtype="math" data-content="H/N" contenteditable="false" class="render-node"></span>在<span data-type="inline-math" data-subtype="math" data-content="G/N" contenteditable="false" class="render-node"></span>中是正规子群。</p>
<p id="20240314100232-8qzjd5y" updated="20240314100232">而反过来的构造比较复杂，构造了同态<span data-type="inline-math" data-subtype="math" data-content="G\rightarrow G/N" contenteditable="false" class="render-node"></span>与<span data-type="inline-math" data-subtype="math" data-content="G/N\rightarrow\frac{G/N}{H/N}" contenteditable="false" class="render-node"></span>，因为<span data-type="inline-math" data-subtype="math" data-content="H/N" contenteditable="false" class="render-node"></span>是<span data-type="inline-math" data-subtype="math" data-content="G/N" contenteditable="false" class="render-node"></span>中的正规子群，所以这两个同态都是natural homomorphism，后者的核是<span data-type="inline-math" data-subtype="math" data-content="H/N" contenteditable="false" class="render-node"></span>，而使得<span data-type="inline-math" data-subtype="math" data-content="gN\in H/N" contenteditable="false" class="render-node"></span>的元素<span data-type="inline-math" data-subtype="math" data-content="g" contenteditable="false" class="render-node"></span>都属于<span data-type="inline-math" data-subtype="math" data-content="H
" contenteditable="false" class="render-node"></span>，故同态<span data-type="inline-math" data-subtype="math" data-content="G\rightarrow G/N\rightarrow\frac{G/N}{H/N}" contenteditable="false" class="render-node"></span>的核是<span data-type="inline-math" data-subtype="math" data-content="H" contenteditable="false" class="render-node"></span>，所以<span data-type="inline-math" data-subtype="math" data-content="H" contenteditable="false" class="render-node"></span>是正规子群。</p>
<p id="20240314100232-ywsrg1v" updated="20240314100232">Third Isomorphism Theorem：</p>
<blockquote id="20240314100232-turgmbl" updated="20240314100232">
<p id="20240314100232-3d7voq4" updated="20240314100232">如果<span data-type="inline-math" data-subtype="math" data-content="H,N" contenteditable="false" class="render-node"></span>是群<span data-type="inline-math" data-subtype="math" data-content="G" contenteditable="false" class="render-node"></span>的正规子群且<span data-type="inline-math" data-subtype="math" data-content="N\sub H" contenteditable="false" class="render-node"></span>，则<span data-type="inline-math" data-subtype="math" data-content="G/H\cong \frac{G/N}{H/N}" contenteditable="false" class="render-node"></span>。</p>
</blockquote>
<p id="20240314100232-qmu11ui" updated="20240314100232">这个定理实际上在上一个证明过程中被证明了。最后的同态<span data-type="inline-math" data-subtype="math" data-content="G\rightarrow \frac{G/N}{H/N}" contenteditable="false" class="render-node"></span>的核是<span data-type="inline-math" data-subtype="math" data-content="H" contenteditable="false" class="render-node"></span>，所以根据同构第一定理有<span data-type="inline-math" data-subtype="math" data-content="G/H\cong \frac{G/N}{H/N}" contenteditable="false" class="render-node"></span></p>
<p id="20240314100232-f83v9b3" updated="20240314100232">‍</p>
</div>
<script src="appearance/icons/material/icon.js?3.0.2"></script>
<script src="stage/build/export/protyle-method.js?3.0.2"></script>
<script src="stage/protyle/js/lute/lute.min.js?3.0.2"></script>    
<script>
    window.siyuan = {
      config: {
        appearance: { mode: 0, codeBlockThemeDark: "base16/dracula", codeBlockThemeLight: "github" },
        editor: { 
          codeLineWrap: true,
          fontSize: 22,
          codeLigatures: false,
          plantUMLServePath: "https://www.plantuml.com/plantuml/svg/~1",
          codeSyntaxHighlightLineNum: true,
          katexMacros: JSON.stringify({}),
        }
      },
      languages: {copy:"复制"}
    };
    const previewElement = document.getElementById('preview');
    Protyle.highlightRender(previewElement, "stage/protyle");
    Protyle.mathRender(previewElement, "stage/protyle", false);
    Protyle.mermaidRender(previewElement, "stage/protyle");
    Protyle.flowchartRender(previewElement, "stage/protyle");
    Protyle.graphvizRender(previewElement, "stage/protyle");
    Protyle.chartRender(previewElement, "stage/protyle");
    Protyle.mindmapRender(previewElement, "stage/protyle");
    Protyle.abcRender(previewElement, "stage/protyle");
    Protyle.htmlRender(previewElement);
    Protyle.plantumlRender(previewElement, "stage/protyle");
    document.querySelectorAll(".protyle-action__copy").forEach((item) => {
      item.addEventListener("click", (event) => {
            let text = item.parentElement.nextElementSibling.textContent.trimEnd();
            text = text.replace(/ /g, " "); // Replace non-breaking spaces with normal spaces when copying
            navigator.clipboard.writeText(text);
            event.preventDefault();
            event.stopPropagation();
      })
    });
</script></body></html>